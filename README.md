# python-ml-type-hints

## DeepTyper

Время обучения и работы:  
  Работа -- меньше 2х секунд на не очень больших файлах (время из статьи, экспериментально не проверено)
  Обучение -- в статье не обнаружено.

Суть подхода -- две bidirectional-RNN с объеднияющим их так называемым "consistency layer", который учитывает то, что идентификатор встречается в коде в разных местах (однако не учитывается, что это может быть вхождение разных переменных). Учитывается это с помощью усреднения результата первой RNN для каждого идентификатора по всем его вхождениям в исходный код. 
Замеченные проблемы:  
  - По результативности модель без улучшений (top-1 и top-5 accuracy) слабо отличается от обычной RNN, как указано в самой статье -- top-1 accuracy отличается на 2%, а top-5 accuracy совпадает.
  - Проблема, вытекающая из предыдущей -- есть сравнение продвинутой модели с другими средствами вывода типов, но также хотелось бы сравнить продвинутую теми же способами plain RNN с этими средствами или с самой продвинутой моделью (т.е. есть DeepTyper+CheckJS, хотелось бы сравнить это с RNN+CheckJS, чтобы понять, есть ли какой-то значительный выигрыш) 
  - Исходный код рассматривается как набор литералов, т.е. не используется какая-то структурная информация о коде, н-р AST. Сделано так для того, чтобы использовать уже проверенные и понятные модели.
  - Используется closed-world type suggestion, самые популярные типы покроются, но новые типы в модель не добавить.

Данные:  
  - Первые 1000 проектов с наибольшем количеством звезд на GitHub, состоящие преимущественно из TypeScript кода, из которых удалены проекты с >5000 токенов и проекты, в которых только заголовочные файлы на TypeScript, после чего осталось 776 проектов. После этого на проектах запустили компилятор тайпскрипта, который проставил каждому идентификатору тип (возможно, any)
  
Сравнение:  
  - Бейзлайн -- наивный метод, использующий метод максимального правдоподобия.
  - Plain RNN -- RNN без дополнительного слоя, по точности почти не проигрывает, но есть проблема с констистентностью -- может выдать разным вхождениям одного идентификатора разные типы
  - tsc+CheckJS -- запускается компилятор тайпскрипта, выводит какие-то типы, затем запускается тул CheckJS, который тоже выводит какие-то типы поверх уже выведенных (или пишет any, если не уверен). В этом случае проводилось несколько экспериментов, была добавлена гибридная модель и трешхолд уверенности, которая запускала tsc+CheckJS, а затем запускала DeepTyper, и в тех случаях, где DeepTyper был уверен в своем выборе (т.е. вероятность наиболее вероятного типа больше трешхолда уверенности), модели было разрешено подставлять на место этого типа свой тип (также 2 эксперимента -- в первом было можно заменять только any, во втором любой тип, заметных отличий не было найдено)
  - JSNice -- тул для вывода типов в функциях, обученный на большом корпусе, использует статистику из графов зависимостей. Т.к. доступен только в веб-форме, было проведено только 30 измерений (взяли 30 случайных функций из топ-100 JS проектов на гитхабе и вручную проставили типы для проверки корректности). Здесь также было проведено исследование гибридной модели, где сначала запускался JSNice, а потом там, где он не был уверен, а DeepTyper уверен, проставлялся выведенный DeepTyper тип. С трешхолдом уверенности (т.е. минимальной вероятностью такой, что DeepTyper может проставлять тип, если вероятность его наиболее вероятного типа больше этой вероятности) в 90% точность достигает 65%, а неправильных или не до конца верных результатов не больше 2% (для 167 идентификаторов, требующих вывода типов). Это на 10% больше по точности, чем у JSNice и у DeepTyper с нулевым трешхолдом, но с другой стороны, дает столько же или меньше неправильных результатов.
  

Основные плюсы такого подхода -- учитываются разные вхождения одного идентификатора (что не сильно увеличивает точность, но снижает количество ошибок, когда разным вхождениям предлагается разный тип), не используется структурная информация об исходном коде (может быть как плюсом, так и минусом -- как плюс, не нужно делать сложных действий, чтобы мигрировать с одного языка на другой, минус -- упускаются особенности конкретного языка, который можно было бы использовать)
